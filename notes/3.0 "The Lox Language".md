
```
print "Hello,world";
```

In this section I'm just going to speedrun some Lox semantics from the book. But first lets go over some attributes of the language.

* **Dynamic Typing**: Lox is dynamically typed. Variables can store values of any type, and a single variable can even store values of different types at different types. If you try to perform an operation on values of the wrong type, (ex. dividing a number by a string), the error is detected and reported at runtime.
* **Automatic memory management**: Lox is going to use its own garbage collector.

## Data Types

**Booleans**
```
true; // Not false.
false; // Not true.
```

**Numbers (Double-precision floating point)**
```
1234; // An integer.
12.34 // A decimal number.
```

**Strings**
```
"I am a string";
""; // empty strying
"123" // not a number, but a string.
```

**Nil**
* "No value", null, or undefined. 

## Expressions

**Arithmetic**
```
add + me;
subtract - me;
multiply * me;
divide / me;
```
The subexpressions on either side of the operator are **operands**. Because there are two of them, they are called **binary** operators. The operators between the operands are called **infix** operators because they are fixed in the middle of the operands (as opposed to prefix operators that come before the operands and postfix operators that come after).

**Comparison and equality**
```
less < than;
lessThan <= orEqual;
greater > than;
greaterThan >= orEqual;
```

```
1 == 2;         // false.
"cat" != "dog"; // true.
```

```
314 == "pi"; // false.
```
**Note:** values of different types are never equivalent anyway.

**Logical operators**

```
!true;  // false.
!false; // true.

true and false; // false.
true and true;  // true.

false or false; // false.
true or false;  // true.
```

## Statements
Expressions produce values, statements produce effects. By this definition statements don't evaluate to a value, but they have to otherwise change the world in some way. For example, that print line at the beginning was a statement.

An expression followed by a semicolon promotes the expression to statement-hood. This is called an expression statement. If you want to unpack a series of statements where one is expected, you can wrap them in a **block**, which also affect scoping.

## Variables
You can declare variables using `var` statements, and if you don't assign it a value it'll automatically be nil.

```
var imAVariable = "here is my value";
var iAmNil;

var breakfast = "bagels";
print breakfast; // "bagels".
breakfast = "beignets";
print breakfast; // "beignets".
```

## Control Flow

**if Statements**
```
if (condition) {
  print "yes";
} else {
  print "no";
}
```

**while Loop**
```
var a = 1;
while (a < 10) {
  print a;
  a = a + 1;
}
```

**for Loop**
```
for (var a = 1; a < 10; a = a + 1) {
  print a;
}
```

Java ahh syntax

## Functions
**Calling Functions**
```
makeBreakfast(bacon, eggs, toast); // call function w/ args
makeBreakfast(); // call functino w/o args
```
**Defining Functions**
```
fun printSum(a, b) {
  print a + b;
}
```

**Semantics:**
* **Argument**: Actual value you pass to a function when you call it.
* **Parameter**: Variable that holds the value of the argument in the body of the function.

**Defining Functions w/ return**
```
fun returnSum(a, b) {
  return a + b;
}
```

## Closures
Functions are *first class* in Lox, which just means they are real values you can get a reference to, store in variables, pass around etc.
```
fun addPair(a, b) {
  return a + b;
}

fun identity(a) {
  return a;
}

print identity(addPair)(1, 2); // Prints "3".
```

Since function declarations are statements, you can declare local functions inside another function.

```
fun outerFunction() {
  fun localFunction() {
    print "I'm local!";
  }

  localFunction();
}
```

If you combine local functions, first class functions, and block scope, you run into this interesting situation:

```
fun returnFunction() {
	var outside = "outside";
	fun inner() {
		print outside;
	}
	return inner;
}
var fn = returnFunction();
fn();
```
Here, `inner()` accesses a local variable that's declared outside of its body. For that to work, `inner()` need to "hold on" to any references to any surrounding variables that it uses so that they stay around even after the outer function has returned. We call functions that do this **closures**. These days, the term is often used for any first class function, but this is a misnomer if the function doesn't happen to close over any variables. This adds complexity to variable scope, and makes it such that we can't just implement a stack that evaporates local variables the moment the function returns.

## Object Oriented
### Classes or Prototypes
When it comes to objects, you can either use classes or prototypes. Classes came first, and are more common because they're used in Java, C++, etc. Prototypes were practically forgotten until JavaScript. In class-based languages, there are two core concepts: instances and classes. Instances store the state for each object and have a reference to the instance's class Classes contain methods and inheritance chain. To call a method an instance, there is always a level of indirection. You look up the instance's class and you find the method there.
![[Pasted image 20251202235833.png]]
Prototype based languages merge these two concepts. There are only objects, no classes, and each individual object may contain state and methods. Objects can idireclty inherit from each other (or "delegate to.")
![[Pasted image 20251203000518.png]]
This means that in some ways prototypal languages are more fundamental than classes. They are really neat to implement because they're so simple. Also, they can express lots of unusual patterns that classes steer you away from.

## Classes in Lox

```
class Breakfast {
	cook() {
		print "Eggs a-fryin'!";
	}
	
	serve(who) {
		print "Enjoy your breakfast," + who ".";
	}
}
```

The body of the class contains its methods. They look like function declarations but without the `fun` keyword. When the class declaration is executed, Lox creates a class object and stores that in a variable named after the class. Just like functions, classes are first class in Lox.

```
// Store it in variables.
var someVariable = Breakfast;
// Pass it to functions.
someFunction(Breakfast);
```
Next, we need a way to create instances. To keep things simple, in the lox class itself is a factory function for instances. Call a class like a function, and it produces an instance of itself.
```
var breakfast = Breakfast();
print breakfast; // "Breakfast instance".
```

### Instantiation and initialization
Classes that only have behavior aren't super useful, they also need to store state. To do that, you need fields. Lox will allow you to freely add properties onto objects.
```
breakfast.meat = "sausage";
breakfast.bread = "sourdough";
```

Assigning a field creates that field if it doesn't exist. You can access a field or method on the current object from within a method. You'll do this using `this`.

```
class Breakfast {
	serve(who) {
		print "Enjoy your " + this.meat + " and " +
		this.bread + ", " + who + ".";
	}
}
```

We're also going to add an `init()` method that when initialized in a class, is automatically called when an object is constructed. Any parameters passed to the class are forwarded to this initializer.

```
class Breakfast {
	init(meat, bread) {
		this.meat = meat;
		this.bread = bread;
	}
	// …
}

var = baconAndToast = Breakfast("bacon","toast");
baconAndToast.serve("Dear Reader")
```

### Inheritance
every object oriented language lets you define methods as well as reuse them across multiple classes or objects. Lox supports single inheritance. When you declare a class, you can specify a class that it inherits from using a less-than ( < ) operator.

```
class Brunch < Breakfast {
	drink() {
		print "How about a Bloody Mary?";
	}
}
```

Here, Brunch is the derived class or subclass, with Breakfast being the base class or superclass. Even the `init()` method gets inherited. In practice, the subclass usually wants to define its own `init()` method too. But the original one also needs to be called so that the superclass can maintain its state.  We need some way to call a method on our own instance without hitting our own methods.

For this, you'll use `super`.

```
class Brunch < Breakfast {
	init(meat, bread, drink){
		super.init(meat, bread);
		this.drink = drink;
	}
}
```

## The Standard Library
We're just gonna have `print` and `clock()`.