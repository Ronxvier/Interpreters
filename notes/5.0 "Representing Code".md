### Terminology
#### Lexical Grammar
**The alphabet is...** -> Characters
**A "string" is...**  -> Lexeme or token
**It's implemented by the...** -> Scanner

#### Syntactic Grammar
**The alphabet is...** -> Tokens
**A "string" is...**  -> Expression
**It's implemented by the...** -> Parser

### Rules for grammars
We need to write down a grammar that contains an infinite number of strings. This can be done by creating a finite set of rules. If you start with the rules, you can use them to generate strings that are in the grammar. Strings created this way are called **derivations** as they are derived from the rules of the grammar. Rules are called **productions** because they produce strings in the grammar.

Each production in a context-free grammar has a **head** (name) and a **body**, that describes what it generates.

### Types of bodies
* **Terminal:** A letter from the grammar's alphabet, like a literal value.  In the grammar we're defining, they are individual lexemes, tokens coming from the scanner like `if` or `1234`.
	They're called terminals because they don't lead to any further moves, they are the end point. You simply produce that one symbol.

* **Nonterminal:** A named reference to another rule in the grammar.

There is one last refinement, that you can have multiple rules with the same name. When you reach a nonterminal with that name, you are allowed to pick any rules for it.

### A Grammar for Lox expressions
We'll start by working through a subset of the lox language in the next couple of chapters. Once the mini-language is represented, parsed, and interpreted, then later we can add features to it. Here are the expressions we will work with for now.

* **Literals.** Numbers, strings, Booleans, and `nil`.
* **Unary expressions.** A prefix `!` to perform a logical not, `-` to negate a number.
* **Binary expressions.** The infix arithmetic (`+`,`-`,`*`,`/`) and logic operators (`==`, `!=`,`<`,`<=`,`>`,`>=`)
* **Parentheses.** A pair of `(` and `)` wrapped around an expression.

```
expression     → literal
               | unary
               | binary
               | grouping ;

literal        → NUMBER | STRING | "true" | "false" | "nil" ;
grouping       → "(" expression ")" ;
unary          → ( "-" | "!" ) expression ;
binary         → expression operator expression ;
operator       → "==" | "!=" | "<" | "<=" | ">" | ">="
               | "+"  | "-"  | "*" | "/" ;
```

^ Excerpt from crafting interpreters that uses this notation to describe this grammar.

### Implementing Syntax Trees
Since the grammar is recursive (`grouping`, `unary`, and `binary` all refer back to `expression`) our data structure will form a tree. Since this structure represents the syntax of our language, it's called a **syntax tree**, with every single grammar production becoming a node in the tree.

The scanner use a single Token class to represent different kinds of lexemes, using the TokenType enum to distinguish between the types Syntax trees are different as they're structured differently. For example, Unary expressions have a single operand, binary expressions have two, and literals have none. So to structure all of them under the same singular "expression" class apparently isn't the best way to get the most out of java's type system.

Instead we can create an expression base class for expressions, and create subclasses for each type of expression that takes in nonterminal inputs and structures them.

```java
abstract class Expr {
    static class Binary extends Expr {
        final Expr left;
        final Token operator;
        final Expr right;
        Binary(Expr left, Token operator, Expr right) {
            this.left = left;
            this.operator = operator;
            this.right =  right;
        }
    }
    static class Literal extends Expr {
        final Token value;
        Literal(Token value) {
            this.value = value;
        }
    }
    static class Unary extends Expr {
        final Token prefix;
        Unary(Token prefix) {
            this.prefix = prefix;
        }
    }
    static class Grouping {
        final Expr expression;
        Grouping(Expr expression) {
            this.expression = expression;
        }
    }
}
```
^ my implementation of this idea. This isn't actually used in the jlox implementation, because apparently there's an easier way to automate this process instead of writing out all of these behaviorless classes.

It's important to note why these types exist in the first place. Trees exists as an **intermediate representation** between the scanner and the parser. This is why the classes have no methods, for the process of building trees doesn't necessarily mean that the data types that make up the nodes need to have behavior themselves.

Now the course goes into how to create a small cli app for the generation of these dataless classes, which I won't be going into in these notes because they aren't really related to the interpreter.